uC/OS-III的学习
上Micrium官网下载源码  https://www.micrium.com/
1、uC/OS-III是一个可裁剪（条件编译），可固化，可剥夺型的多任务内核，没有任务数目限制。

2、当任务在等待一个事件时，它不会占用CPU时间（这个等待事件可以是延时，信号量，消息）。

3、uC/OS-III提供的内核对象：任务、信号量、互斥性信号量、事件标记、消息队列、定时器和存储块等。

4、uC/OS-III有两个调度器，在任务级代码使用OSSched(),而在中断服务程序结束时则调用OSIntExit()。

5、uC/OS-III允许在同一优先级下有多个任务，在这些任务间，uC/OS-III将会使用时间片轮转调度算法。

6、uC/OS-III通常需要用户提供一个周期性的中断来实现延时和超时等相关操作，这个周期性的时钟叫"时钟节拍"，频率通常在10~1000Hz之间。
   (1M Hz tick = 1us)    (10 Hz  tick = 0.1s)  (1000Hz tick = 1ms)
   
7、uC/OS-III的大多数API函数在运行结束后会返回一个错误类型码。对于所有产生错误返回码的服务函数，其最后一个参数就是指向该错误类型码的指针。

8、uC/OS-III CPU相关的代码（Ports）【os_cpu.h、os_cpu_a.asm、os_cpu_c.c】
   这部分uC/OS-III代码需要根据特定的CPU架构进行修改，该过程称为移植。
	
9、uC/CPU  CPU相关代码【cpu_def.h、cpu_c.c、cpu_a.asm、cpu_core.c、cpu_core.h】
   Micrium公司将CPU相关功能代码封装起来，这些文件定义了打开和关闭中断的函数、与CPU和使用的编译器有关的CPU_XXX数据类型和其它的函数。

10、uC/OS-III对从中断发布消息或信号的处理有两种模式：直接发布和延迟发布。在OS_cfg.h中OS_CFG_ISR_POST_DEFERRED_EN设置成0，使用直接发布模式，
	设置成1，使用延迟发布模式。直接发布模式使用关闭中断的方式来保护临界段代码，延时发布模式通过给调度器上锁的方式来保护临界段代码。
	
11、uC/OS-III包含许多调度点，各种调度点下，调度器会自动启动，用户程序无需进行特殊的操作
	调度点一：任务释放信号量给另一任务或者向另一个任务发消息。
	调度点二：任务调用延时函数OSTimeDly()或者OSTimeHMSM()。
	调度点三：任务等待事件发生而事件还没发生。
	调度点四：任务取消等待。
	调度点五：创建任务、删除任务、删除一个内核对象。
	调度点六：任务改变自身的优先级或者其他任务的优先级。
	调度点七：任务通过调用OSTaskSuspend()将自身挂起。
	调度点八：任务"解除挂起"某一调用OSTaskSuspend()挂起的任务。
	调度点九：退出所有的中断嵌套。
	调度点十：通过OSSchedUnlock()给调度器解锁。
	调度点十一：任务调用OSSchedRoundRobinYield()放弃其执行的时间片。
	调度点十二：用户调用OSSched()。
	
12、任务切换：当任务级调度器（OSSched()）确定有一个新的高优先级的任务需要执行时，就会调用OSCtxSw()【见os_cpu_a.asm】
			  当中断级的调度器（OSIntExit())确定有一个新的高优先级的任务需要执行时，就会调用OSIntCtxSw()【见os_cpu_a.asm】

13、在调度器上锁的情况下，中断服务程序总是会返回至被打断的任务中去，只有在调度器解锁后，才会在那些具有高优先级的任务进入就绪态后，执行任务切换。

14、OSSchedLock()和OSSchedUnlock()可以嵌套250层，只有当OSSchedUnlock()调用的次数和OSSchedLock()相等时，系统才会答应调度请求。

15、uC/OS-III中最常用的独占共享资源和创建临界区的方法有以下几种：
	·关中断（因为中断往往会造成更高优先级的任务进入就绪态，从而造成当前任务的CPU使用权被剥夺）
	·禁止任务调度
	·使用信号量（信号量是一种被定义为OS_SEM数据类型的内核对象）
	·使用互斥性信号量（也称做mutex）
	
16、在实时系统中使用信号量有可能导致一个严重的问题———优先级反转

17、uC/OS-III对二进制与计数型信号量并不加以区分对待。二者是在信号量被创建时被确立的，如果创建信号量时，将其初始化
	为1，则他是一个二进制信号量，如果初始化的值大于1，则它是一个计数型信号量。
	
18、关于信号量：
		·在os_cfg.h中OS_CFG_ARG_CHK_EN使能
		·参数设置 
				阻塞类型：OS_OPT_PEND_NON_BLOCKING   / OS_OPT_PEND_BLOCKING
						  如果信号量的计数器为0，在OS_OPT_PEND_NON_BLOCKING下，OSSEMPend()将会立即返回，并向调用者返回错误代码以说明信号量此时无效。
						  在OS_OPT_PEND_BLOCKING选项下，调用的任务将会被插入到挂起表中。任务在挂起表中的位置根据优先级决定，最高优先级的任务总是在表的头部。
						  
				Timeout：0/ >0  如果用户设定了一个不为0的超时时间,任务会被插入到一个时钟节拍表中，如果设定为0，表明用户愿意任务无限制的等待下去，直到信号量被释放。
		返回值：OS_ERR_NONE ...
				如果OSSEMPend()返回的错误代码是OS_ERR_NONE，则用户的代码便可以访问共享资源了。
19、互斥型信号量：MUTEX——解决无界优先级反转
		· uC/OS-III支持完全优先级继承，一个低优先级的任务在使用共享资源的时候，一旦一个具有高优先级的任务想要访问共享资源，占有该资源的任务
			的优先级将被提升至与高任务优先级一个级别。
		· 与信号量一样，只有任务才能使用互斥性信号量，中断服务程序则不可以。【中断服务程序只能发布，不能等待】
		· 常规调用   创建 OSMutexCreate()  |  等待 OSMutexPend()  |  释放OSMutexPost()

20、避免出现死锁的方法：
		·先得到全部需要的资源，再做下一步工作
		·用相同的顺序申请多个资源
		·在调用请求信号量的函数时设定超时时间
		
------------------任务同步---------------------------		
21、uC/OS-III中有两种基本的同步机制：信号量和事件标记
	
22、信用记录：信号量可以被记住发布了多少次，如果等待事件的任务成为最高优先级任务之前ISR发生了很多次，那么信号量
			  会被记录发布的次数，当任务成为优先级最高的就绪任务时，该任务也会连续执行多次，执行的次数与发布信号量的次数相同。
			  
23、任务通过调用OSSemPost()函数发布信号量，内部参数设置：
		当指定OS_OPT_POST_1选项时，表明用户希望只给一个任务发信号（在多任务等待同一个信号量时），等待该信号量的最高优先级任务将进入就绪态，
			如果有多个任务具有相同的优先级，则这些任务中只有一个任务进入就绪态。
		当指定OS_OPT_POST_ALL选项时，信号量会发布给所有等待该信号量的任务，所有的任务都进入就绪态。
		
24、任务信号量：
		在uC/OS-III中，每个任务都有它自己的内嵌信号量，当创建任务时，任务信号量会被自动创建，且初始计数为零。
		等待任务信号量: OSTaskSemPend();
			参数：1、timeout
				  2、等待方式 OS_OPT_PEND_NON_BLOCKING  / OS_OPT_PEND_BLOCKING
				  3、ts
				  4、err
		发布任务信号量：OSTaskSemPost();
			参数：1、&TaskTCB 目标任务控制块
				  2、发布任务信号量的方式：
						当指定OS_OPT_POST_NONE选项时，表明在发布任务信号量之后调用调度程序，此选项为默认选项。
						当指定OS_OPT_POST_NO_SCHED选项时，表明在OSTaskSemPost()的末尾不会调用调度程序，在所有的操作都完成时才需要调用调度程序。
						
				  3、err
25、事件标志组：
		·任务和ISR都可以发布事件标志，但是，只有任务可以创建、删除事件标志组以及取消其它任务对事件标志组的等待。
		·相关的服务函数：
			OSFlagCreate() //创建事件标志组
			OSFlagDel()    //删除事件标志组
			OSFlagPend()   //等待事件标志
			OSFlagPost()   //向事件标志组发布标志
			
26、事件标志通常有两种用途：状态信息监控和瞬间事件监控 
		应用程序员可以创建任意多个事件标志组,（被可用RAM空间限制）

27、ISR和任务都可以通过三种方式向一个或多个任务发信号：信号量、任务信号量、事件标志组
	如果ISR或任务需要给单个任务发信号，则使用任务信号量更合理，因为使用任务信号量时不需要在声明一个外部信号量对象
	而且，任务信号量服务函数的执行速度也比信号量服务函数的执行速度要快。
	
28、当任务需要与一个或多个事件的发生同步时，可以使用事件标志，但是事件标志暂不支持信用记录功能，因为事件标志组中的每个事件用一个数据位表示（而不是使用计数器）

29、一个任务或者中断服务程序有时候需要和另外一个任务交流信息，这个信息传递的过程称为任务间通信。
	任务间的信息传递可以通过两种途径实现：一是通过全局变量，二是通过发布消息。

30、任务想要与中断服务程序通信，只能通过全局变量，在这种情况下，任务并不知道全局变量在何时会被中断服务程序修改
	除非中断服务程序通知任务，或者任务不定期地查询全局变量的值。
	
31、消息可以通过消息队列作为中介发布给任务，也可以直接发布给任务，因为在uC/OS-III中，每一个任务都有内建的消息队列。
	任务在等待消息时不占用CPU时间。
	
32、消息队列是一种由用户程序分配的内核对象。用户可以分配任意数量的消息队列，唯一的限制就是可用的RAM区的容量
	用户可以对消息队列进行一系列的相关操作，而中断服务程序只能调用OSQPost()。
	
33、对消息队列的读取采用先进先出(FIFO)的方式，在uC/OS-III中，也可以采用后进先出（LIFO）的方式发布消息。
	
34、在uC/OS-III中，每一个任务都有内建的消息队列，用户可以不用通过外部的消息队列而直接向任务发布消息，
	该特性不但简化了代码，而且比使用通过外部的消息队列更加高效。

35、发送的消息通常是一个指针，指向结构体、变量、数组或者表格等。一定要注意的是，这些数据必须保持不变，直到接受者完成相应的数据处理。
	发布方一旦发出一则消息，就不能再修改对应的内容。
	
36、uC/OS-III消息队列相关的API
		·OSQCreate() 创建一个消息队列
		·OSQDel() 删除一个消息队列
		·OSQFlush() 清空消息队列
		·OSQPend() 等待消息
		·OSQPost() 向消息队列发布一则消息
		·OSQPendAbort() 取消等待消息
37、uC/OS-III内建的消息队列API
		·OSTaskQPend() 等待消息
		·OSTaskQPost() 向任务发布一则消息
		·OSTaskQFlush() 清空任务的消息队列
		·OSTaskQPendAbort() 取消等待消息

38、一个任务可以同时等待任意数量的信号量和消息队列，第一个信号量或消息队列发布的发布会导致该任务进入就绪态，并和就虚表中的其它任务竞争CPU时间。

39、OSPendMulti() 仅允许同时等待多个信号量和消息队列，不允许同时等待事件标志组和互斥型信号量。

40、如果OSPendMuti()被调用时已经有对象被发送成功了，那么uC/OS-III将指定表中那些对象被发送了。

存储管理
41、通常应用程序可以调用ANSI C编译器的malloc()和free()函数来动态地分配和释放存储空间，然而在嵌入式实时操作系统中
	这样做可能很危险，多次进行这样的操作会把原来很大的一块存储区域，逐渐地分割成许多非常小且彼此不相邻的存储区域，这就是存储碎片。
	

42、
















	
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   